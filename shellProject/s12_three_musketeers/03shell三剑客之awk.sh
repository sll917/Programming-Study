#!/bin/bash
# **********************************************************
# * Author : liangliangsu
# * Email : sll917@hotmail.com
# * Create time : 2022-10-09 16:48
# * Filename : 01awk.sh
# **********************************************************
: <<!
AWK 工作原理
AWK 工作流程可分为三个部分：
1, 读输入文件之前执行的代码段（由BEGIN关键字标识）。
2, 主循环执行输入文件的代码段。
3, 读输入文件之后的代码段（由END关键字标识）。
命令结构:
awk 'BEGIN{ commands } pattern{ commands } END{ commands }'
awk '条件类型1{动作1} 条件类型2{动作2} ...' filename

1、通过关键字 BEGIN 执行 BEGIN 块的内容，即 BEGIN 后花括号 {} 的内容。
2、完成 BEGIN 块的执行，开始执行body块。
3、读入有 \n 换行符分割的记录。
4、将记录按指定的域分隔符划分域，填充域，$0 则表示所有域(即一行内容)，$1 表示第一个域，$n 表示第 n 个域。
5、依次执行各 BODY 块，pattern 部分匹配该行内容成功后，才会执行 awk-commands 的内容。
6、循环读取并执行各行直到文件结束，完成body块执行。
7、开始 END 块执行，END 块可以输出最终结果。

开始块（BEGIN）
开始块的语法格式如下：
BEGIN {awk-commands}
开始块就是在程序启动的时候执行的代码部分，并且它在整个过程中只执行一次。
一般情况下，我们可以在开始块中初始化一些变量。
BEGIN 是 AWK 的关键字，因此它必须是大写的。
注意：开始块部分是可选的，你的程序可以没有开始块部分。

主体块（BODY）
主体部分的语法格式如下：
/pattern/ {awk-commands}
对于每一个输入的行都会执行一次主体部分的命令。
默认情况下，对于输入的每一行，AWK 都会执行命令。但是，我们可以将其限定在指定的模式中。
注意：在主体块部分没有关键字存在。

结束块（END）
结束块的语法格式如下：
END {awk-commands}
结束块是在程序结束时执行的代码。 END 也是 AWK 的关键字，它也必须大写。与开始块相似，结束块也是可选

1、AWK简介
AWK是一种处理文本文件的语言，是一个强大的文本分析工具。
2、AWK语法
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)

选项参数的说明：
-F fs or –field-separator fs
指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:

-v var=value or –asign var=value
赋值一个用户定义变量。

-f scripfile or –file scriptfile
从脚本文件中读取awk命令。

-mf nnn and -mr nnn
对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。

-W compact or –compat, -W traditional or –traditional
在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。

-W copyleft or –copyleft, -W copyright or –copyright
打印简短的版权信息。

-W help or –help, -W usage or –usage
打印全部awk选项和每个选项的简短说明。

-W lint or –lint
打印不能向传统unix平台移植的结构的警告。

-W lint-old or –lint-old
打印关于不能向传统unix平台移植的结构的警告。

-W posix
打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符和=不能代替^和^=；fflush无效。

-W re-interval or –re-inerval
允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。

-W source program-text or –source program-text
使用program-text作为源代码，可与-f命令混用。

-W version or –version
打印bug报告信息的版本。

内建变量
属性		说明
$0			当前记录（作为单个变量）
$1~$n		当前记录的第n个字段，字段间由FS分隔
FS			输入字段分隔符 默认是空格
NF			当前记录中的字段个数，就是有多少列
NR			已经读出的记录数，就是行号，从1开始
RS          输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
OFS			输出字段分隔符 默认也是空格
ORS			输出的记录分隔符，默认为换行符
ARGC		命令行参数个数
ARGV		命令行参数数组
FILENAME	当前输入文件的名字
IGNORECASE	如果为真，则进行忽略大小写的匹配
ARGIND		当前被处理文件的ARGV标志符
CONVFMT		数字转换格式 %.6g
ENVIRON		UNIX环境变量
ERRNO		UNIX系统错误消息
FIELDWIDTHS	输入字段宽度的空白分隔字符串
FNR			当前记录数
OFMT		数字的输出格式(默认值是%.6g)
RSTART		被匹配函数匹配的字符串首
RLENGTH		被匹配函数匹配的字符串长度
SUBSEP		数组下标分隔符(默认值是\034)

awk是行处理器: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息
awk处理过程: 依次对每一行进行处理，然后输出
awk命令形式:
awk [-F|-f|-v] 'BEGIN{} //{command1; command2} END{}' file

[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value
'  '         引用代码块
BEGIN		 在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符
//           匹配代码块，可以是字符串或正则表达式
{}           命令代码块，包含一条或多条命令
；          多条命令使用分号分隔
END         在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息

(1)特殊要点:
$0           表示整个当前行
$1           每行第一个字段
NF           字段数量变量
NR           每行的记录号，多文件记录递增
FNR          与NR类似，不过多文件记录不递增，每个文件都从1开始
\t           制表符
\n           换行符
FS           BEGIN时定义分隔符
RS           输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
~            匹配，与==相比不是精确比较
!~           不匹配，不精确比较
==           等于，必须全部相等，精确比较
!=           不等于，精确比较
&&　         逻辑与
||           逻辑或
+            匹配时表示1个或1个以上
/[0-9][0-9]+/   两个或两个以上数字
/[0-9][0-9]*/    一个或一个以上数字
FILENAME 文件名
OFS         输出字段分隔符， 默认也是空格，可以改为制表符等
ORS         输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
-F'[:#/]'   定义三个分隔符
!

echo '(1)-----------------------完美分割线--------------------------------'
# 1, print & $0
#print 是awk打印指定内容的主要命令
awk '{print}'  /etc/passwd | head -3
awk '{print $0}'  /etc/passwd | head -3

echo '(2)-----------------------完美分割线--------------------------------'
awk '{print " "}' /etc/passwd | head -3 
#不输出passwd的内容，而是输出相同个数的空行

echo '(3)-----------------------完美分割线--------------------------------'
awk -F":" '{print $1}'  /etc/passwd| head -3  

echo '(4)-----------------------完美分割线--------------------------------'
awk -F: '{print$1;print$2}' /etc/passwd | head -3  
#将每一行的前二个字段，分行输出，进一步理解一行一行处理文本

echo '(5)-----------------------完美分割线--------------------------------'
awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd | head -3         
#输出字段1,3,6，以制表符作为分隔符

#输出处理结果到文件
route -n|awk 'NR!=1{print >> "./regular_awk.txt"}' 
#1,在命令代码块中直接输出
route -n|awk 'NR!=1{print}'  >> ./regular_awk.txt   
#2,使用重定向进行输出

#格式化输出
echo '(6)-----------------------完美分割线--------------------------------'
sudo netstat -anp|awk 'NR<=10 {printf "%-8s %-8s %-10s\n",$1,$2,$3}'
echo '(7)-----------------------完美分割线--------------------------------'
awk '{printf "%-8s %-10s\n", $1,$4}' regular_awk.txt | head -3         
# printf表示格式输出
# %格式化输出分隔符
# -8长度为8个字符
# s表示字符串类型
# 打印每行前三个字段，指定第一个字段输出字符串类型(长度为8)，第二个字段输出字符串类型(长度为8),
# 第三个字段输出字符串类型(长度为10)

echo '(8)-----------------------完美分割线--------------------------------'
sudo netstat -anp|awk '$6=="LISTEN" || NR==1 {printf "%-10s %-10s %-10s \n",$1,$2,$3}' | head -3         

echo '(9)-----------------------完美分割线--------------------------------'
sudo netstat -anp|awk '$6=="LISTEN" || NR==1 {printf "%-3s %-10s %-10s %-10s \n",NR,$1,$2,$3}'| head -3         

: '
2, -F指定分隔符 -F相当于内置变量FS, 指定分割字符
1指指定分隔符后，第一个字段，3第三个字段， \t是制表符
一个或多个连续的空格或制表符看做一个定界符，即多个空格看做一个空格
'
echo '(10)-----------------------完美分割线--------------------------------'
awk -F":" '{print $1$3}'  /etc/passwd | head -3                       #1与3相连输出，不分隔

echo '(11)-----------------------完美分割线--------------------------------'
awk -F":" '{print $1,$3}'  /etc/passwd | head -3                       #多了一个逗号，1与3使用空格分隔

echo '(12)-----------------------完美分割线--------------------------------'
awk -F":" '{print $1" "$3}'  /etc/passwd | head -3                  #1与3之间手动添加空格分隔

echo '(13)-----------------------完美分割线--------------------------------'
awk -F":" '{print "Username:" $1 "\t\t Uid:"$3 }' /etc/passwd | head -3       #自定义输出

echo '(14)-----------------------完美分割线--------------------------------'
awk -F: '{print NF}' /etc/passwd | head -3                                #显示每行有多少字段

echo '(15)-----------------------完美分割线--------------------------------'
awk -F: '{print $NF}' /etc/passwd | head -3                              #将每行第NF个字段的值打印出来

echo '(16)-----------------------完美分割线--------------------------------'
 awk -F: 'NF==7 {print }' /etc/passwd | head -3                       

echo '(17)-----------------------完美分割线--------------------------------'
awk -F: 'NF>2{print $0}' /etc/passwd | head -3                       #显示每行字段数量大于2的行

echo '(18)-----------------------完美分割线--------------------------------'
awk '{print NR,$0}' /etc/passwd | head -3                                 #输出每行的行号

echo '(19)-----------------------完美分割线--------------------------------'
awk -F: '{print NR,NF,$NF"\t",$0}' /etc/passwd | head -3  #依次打印行号，字段数，最后字段值，制表符，每行内容

echo '(20)-----------------------完美分割线--------------------------------'
awk -F: 'NR==3{print}'  /etc/passwd | head -3                         #显示第3行

echo '(21)-----------------------完美分割线--------------------------------'
awk -F: 'NR==5 || NR==6{print NR,$0}'  /etc/passwd | head -3       #显示第5行和第6行

echo '(22)-----------------------完美分割线--------------------------------'
route -n|awk 'NR!=1{print}'                                       #不显示第一行

echo '(23)-----------------------完美分割线--------------------------------'
awk -F '[ ,]'  '{print $1,$2,$5}' regular_awk.txt |head -5
#使用多个分隔符.先使用空格分割，后对分割结果再使用","分割

echo '(24)-----------------------完美分割线--------------------------------'
cat /etc/passwd | head -3 | awk '{FS=":"} $3 < 10 {print $1 "\t " $3}'

echo '(25)-----------------------完美分割线--------------------------------'
cat /etc/passwd | head -3 | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'

#3, -f指定脚本文件
#awk -f {awk脚本} {文件名}
echo '(26)-----------------------完美分割线--------------------------------'
awk 'BEGIN{X=0} /^$/{ X+=1 } END{print "I find",X,"blank lines."}' regular_awk.txt

ls -l|awk 'BEGIN{sum=0} !/^d/{sum+=$5} END{print "total size is",sum}'          
#计算文件大小

#5, awk -v # 设置变量
#实例：
echo '(27)-----------------------完美分割线--------------------------------'
awk -v a=1 '{print $1,$1+a}' regular_awk.txt | head -5

echo '(28)-----------------------完美分割线--------------------------------'
awk -v a=1 -v b=s '{print $1,$1+a,$1b}' regular_awk.txt | head -5

: '
6, /匹配代码块
/纯字符匹配   
!//纯字符不匹配   
~//字段值匹配    
!~//字段值不匹配  
~/a1|a2/字段值匹配a1或a2
'

echo '(29)-----------------------完美分割线--------------------------------'
awk '/sll/{print }' /etc/passwd | head -3

echo '(30)-----------------------完美分割线--------------------------------'
awk '!/sll/{print $0}' /etc/passwd | head -3  
#输出不匹配sll的行

echo '(31)-----------------------完美分割线--------------------------------'
awk '/sll|mail/{print}' /etc/passwd | head -3

echo '(32)-----------------------完美分割线--------------------------------'
awk '!/sll|mail/{print}' /etc/passwd | head -3

echo '(33)-----------------------完美分割线--------------------------------'
awk -F: '/mail/,/sll/{print}' /etc/passwd | head -3         
#区间匹配

echo '(34)-----------------------完美分割线--------------------------------'
awk '/[2][7][7]*/{print $0}' /etc/passwd | head -3          
#匹配包含27为数字开头的行，如27，277，2777...

echo '(35-1)-----------------------完美分割线--------------------------------'
awk -F: '/mail/{print $1}' /etc/passwd | head -3         
echo '(35-2)-----------------------完美分割线--------------------------------'
awk -F: '$1~/mail/{print $1}' /etc/passwd | head -3         
#$1匹配指定内容才显示

echo '(36)-----------------------完美分割线--------------------------------'
awk -F: '{if($1~/mail/) print $1}' /etc/passwd | head -3    
#与上面相同

echo '(37)-----------------------完美分割线--------------------------------'
awk -F: '$1!~/mail/{print $1}' /etc/passwd | head -3         
#不匹配

echo '(38)-----------------------完美分割线--------------------------------'
awk -F: '$1!~/mail|sll/{print $1}' /etc/passwd | head -3
